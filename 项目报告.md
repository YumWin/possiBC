# 项目报告

小组信息

人数：3人 

成员1： 姓名：王博    学号： 181250133    邮箱： 2377651630@qq.com     完成题目数量：200

分工职责：项目的立项答辩；下载解压数据源文件；debug能力和初次构建能力原始评价指标获取；TOPSIS+熵权

法建立学生能力评价模型为每个学生每道题目赋分；ELO实现评价对象匹配；汇报视频剪辑

成员2： 姓名：邱安琪    学号：181250118    邮箱：839868189@qq.com    完成题目数量：200

分工职责：提取项目运用的第三组成员原始数据；RSR秩和比法综合得出学生三项能力得分；项目图片绘制；项目参考信息文档整合与整体框架整合；整合完成中期报告；完成最终项目报告

成员3： 姓名：魏凯旋    学号： 181250151    邮箱： 1219150034@qq.com    完成题目数量：199

分工职责： 自动化批量运行python程序获得能力评价原始数据；熵权法的实现并结合熵权法将题目三项能力的数据整合成为题目类型级别；数据处理全过程用例大数据的运行及相关debug；完成项目ppt   

## 研究问题：挖掘最佳编程CP

## 代码开源地址：https://github.com/YumWin/possiBC

### 代码实现逻辑：

getAllCases文件夹用于得到所有提供的作业数据，其中getGroup3data用于提取出第三组成员的json数据提供给项目使用， getGroup3.py是提取代码，group3test.py用于简单检验，由此得到了group3_data.json的原始数据。initData.py负责下载所有提供的资源文件，unzipData.py作解压缩下载文件之用。

GetRowData文件夹用于从下载文件得到项目三项评价指标需要的所有原始数据，GetAlgorithmCapabilityRowDAT文件夹用于获得算法构建能力需要的原始数据，alglnitData.py用于下载学生最终提交代码,generateTestCaseInputFiles.py用于提取测试用例作为输入文件，InsertMonitorCode.py通过插入监控代码获得程序运行时的时空复杂度等数据，runAndGetProgramMetadate.py进行批量化运行并得到输出文件，generatePreliminaryDataJsonFile.py统计处理得到的输出文件中的数据从而获得算法构建能力所需要的数据。GetFirstConstAndDebugRowDATA文件夹用于获得第一次构建能力和debug能力所需要的原始数据，其中getSimpleFirstCode.py用来下载第一次构建的代码，modifyData.py用来获得两项能力需要的原始数据。

ProgramLevelDataHandler文件夹用于题目粒度下的数据处理，Topsis.py运用TOPSIS模型得到了每名学生每个题目的三项能力评分，作为下一步熵权法处理的数据来源。

ClassLevelDataHandler文件夹用于进一步处理题目粒度下的三项能力评分数据，generateUSERCSVfilesTableOfEachType.py和generateAllCSVtableBody.py用于得到每名学生做的题目的各项数据，并根据三项能力得到3个记录数据的CSV文件,runEntropyMethodGETweight.py通过熵权法获得每项能力下每类题的题目的权重，UserAbilityTypeLevel.py运用上一步得到的权重获得每名学生每类题的三项能力的得分。

UserLevelDataHandler/RSR文件夹进一步处理题型粒度下的三项能力数据得到每名学生的三项能力综合数据。userAbilityRSR.py运用RSR秩和比法获得的每名学生三项能力的RSR评价值，得到了三个EXCEL文件,csvToJson.py将三个EXCEL文件转换为json文件，得到了每名学生了三项能力数据。

eloMatch文件夹中的eloMatch.py将上面得到的每名学生在三项能力，八种题型中的能力值运用elo算法进行匹配，三项能力上采用相似型匹配，八种题型上采用互补型匹配，为每名学生在这两个维度上各推荐了5名编程伙伴。

picture文件夹是绘制样例图片的代码。

## 项目背景

在现在的学习环境中，有着非常多的小组合作项目，各位程度员也有着寻找编程伙伴，进行组队编程的需求，我们的项目适用于学生在学校或院系中通过系统推荐适合与自己合作学习的人组成编程cp，以便在完成各类型的代码题目的过程中取长补短，共同进步。我们的项目仅通过分析本院系学生的python作业情况组配在本院系内的编程cp，当然，这种研究方法也可以拓展到工作中，通过分析员工以往的项目完成情况，按照合适的组配方式组成工作小组，以高效地合作完成新的工作项目。

## 项目目标

我们的目标是建立一个在线oj或者校内在线oj的刷题系统中的一个编程伙伴推荐子系统，可以借鉴moba游戏中的隐藏分rank系统，每个人刷新题后会有个人能力数据更新，同时匹配系统会更新适合结队的编程伙伴，（可以在线交流，例如如果长期都有同一个人为预期伙伴可以结交成长期伙伴，校内则更加方便交流）。同时也可以通过不同的用户预期匹配方式：比如说喜欢旗鼓相当的伙伴或者互补型伙伴从而得到不同的匹配结果。此外，每名学生也可以看自己的能力分布水平，可以看到图形化的信息展示，类似于moba游戏的个人战力系统。

## 研究方法

### 数据预处理

#### 数据爬取和初步处理

**1.处理过程：**

###### 数据爬取阶段：

构建一个能从网上爬取资源的函数，调用six.moves包内部的urllib实现url爬取、os包实现系统路径访问并在urllib.parse包内引入quote实现不同编码之间的转换，通过输入url列表和保存路径，将下载的文件保存到指定路径，并实现下载过程0%到100%的可视化。打开数据json文件，遍历所有题目的url并进行下载。

###### 代码整合阶段：

经组内商议，结合实际需要与程式化设计思想确定了目标保存文件内部：userId->caseType->caseId，在caseId下存放每道题爬取压缩文件的格式，便于后期解压和代码取用。

###### 数据解压阶段：

多次运用zipfile包下的extractall方法对文件夹下文件进行递归解压，将每道题的例题和每次的提交记录在创建对应文件夹后均解压在对应文件夹名的约定文件夹下，便于后期进行统一批处理和数据操作。

**2.处理结果：**

实现了最基础层次数据的获取、解压和序列化，为后期处理原始数据得到初步拟合数据、深度处理得到个人数据并最终运用算法进行组配奠定基础。

#### 运行并获得原始数据

![](https://s1.ax1x.com/2020/07/28/aAw75j.png)

如上图所示：

原始数据为每道题的粒度

每题的评价指标首先分为算法构建能力，debug能力和第一次构建能力

算法构建能力评价需要的原始数据为：代码行数，时间复杂度，空间复杂度

debug能力需要的原始数据为：提交次数，得分涨幅，提交时间

第一次构建能力需要的原始数据为：第一次提交时间，第一次提交得分，第一次提交行数  

##### 算法构建能力处理原理阐述：

需要的原始材料为该学生该道题的最后一次提交代码：因为最后一次的代码提交为学生算法构建最成熟的，也是学生对该题的最终展现形式。能够充分的体现学生算法能力和代码构建的水平。并且python具有简洁性和易用性，因此代码行数一定程度上可以也可以体现学生的构建能力和算法水平，时间复杂度和空间复杂度是传统和科学的评判学生的算法水平和构建水平的指标，分别由程序的运行时间和占用内存大小来具现化

##### 处理过程及结果：

##### 第一阶段：原数材料准备

代码文件通过数据爬取，并另存为本地文件等待处理。储存的路径为home/学生代号/题目类别/题目号/平台提供的题交信息：因为只取最后一次因此只有一个，包含学生提交代码，测试用例等

##### 第二阶段：原始材料预处理为批量化运行脚本提供环境：

首先批量化运行并提取出测试用例为input.txt与源码处于同一文件夹下，并为了实现数据监控：代码运行时间和占用内存的获取，批量化在学生提交源码开头和结尾分别插入一段测试需要代码。从而运行时可以得到代码的运行时间和占用内存信息。至此原始材料预处理完毕

##### 第三阶段：批量化自动运行所有python文件并记录相关数据：

通过python文件批量化运行所有的学生提交的源代码，每个源代码运行完都将结果输出至同一级下的output.txt文件，包含代码本身的输出和运行时间和占用内存大小

通过python文件批量化读取运行产生的output文件并提取出程序运行时间和内存占用大小，再次通过函数，扫描程序文件得到代码行数。

至此三项数据均全部得到，结合每个文件的路径信息（拥有学生号，题目类型和题目号）生成algInitData.json进行储存等待后续数据处理

##### debug能力处理原理阐述：

需要的原始材料为样本数据json文件，评价指标为代码上传次数、第一次提交和最后一次提交分差、第一次提交和最后一次提交时间差。一般情况下，认为代码上传次数越少、前后花费时间越少即该学生对本道题debug的掌握越熟练，第一次提交和最后一次提交的分差越大即该学生对本道题debug的理解越深入，综上因素较为简单易得且逻辑分明、条理清楚，共同促成了debug能力强弱的判断。

##### 处理过程及结果：

打开原始材料样本数据json文件，记录代码上传次数、第一次提交和最后一次提交分差、第一次提交和最后一次提交时间差三项指标，通过python的批量化处理能力将得到的指标输出到一份新建的json文件下，对应目录为userId->case(caseId, caseType, upload_times, deltaScore, deltaTime)，以便后续处理。

##### 初次构建能力处理原理阐述：

需要的原始材料为样本数据json文件以及该学生该道题第一次提交代码，评价指标为第一次提交代码的时间、第一次提交代码的得分情况和第一次提交代码的代码行数。可以认为第一次提交代码的时间越早、第一次提交代码的行数越短，该学生对本道题的初次构建理解能力越强，第一次提交代码的得分越高，该学生对本道题的初次构建掌握程度越高，综上因素清晰明确、自然合理，共同促成了初次构建能力强弱的判断。

##### 处理过程及结果：

打开原始材料样本数据json文件，记录第一次提交代码的时间、第一次提交代码的得分情况两项指标，同时通过python的os包检索经过数据预处理后被下载解压序列化的py代码文件并统计得到第一次提交代码的代码行数这项指标，通过python的批量化处理能力将得到的指标输出到一份新建的json文件下，对应目录为userId->case(caseId, caseType, firstTime, firstScore, firstLines)，以便后续处理。

注：我们爬取和处理的都是第三组同学的编程数据

### 数据处理分层

#### topsis和熵权法构建题目评价模型

##### 该层次数据来源与数据目标

该层次的原始数据来源于初次处理获得的原始数据，即某位学生某道题的三项能力（debug能力，初次构建能力，算法构建能力）的各项指标，以这些评价指标为基础建立TOPSIS结合熵权法的评价模型。在经过TOPSIS结合熵权法优化后的评价模型处理之后，每名学生的每道题目都将拥有debug能力，初次构建能力，算法构建能力这三项能力的一个初步评估值。

##### TOPSIS评价模型

**1.模型概念**

TOPSIS法（Technique for Order Preference by Similarity to Ideal Solution） 可翻译为逼近理想解排序法，国内常简称为优劣解距离法 TOPSIS 法是一种常用的综合评价方法，其能充分利用原始数据的信息， 其结果能精确地反映各评价方案之间的差距。基本过程为先将原始数据矩阵统一指标类型（一般正向化处理） 得到正向化的矩阵，再对正向化的矩阵进行标准化处理以消除各指标量纲的影响，并找到有限方案中的最优方案和最劣方案，然后分别计算各评价对象与最优方案和最劣方案间的距离，获得各评价对象与最优方案的相对接近程度，以此作为评价优劣的依据。该方法对数据分布及样本含量没有严格限制，数据计算简单易行。

**2.具体算法思路**

a.指标正向化

将所有的指标转化为极大型指标，即指标正向化。

极小型指标转换为极大型指标的公式：max-x

本次数据处理中遇到的极大型指标分别为debug能力评估中的得分涨幅，初次构建能力评估中的初次得分，极小型指标是debug能力评估中的上传次数、间隔时间，初次构建能力评估中的初次上传时间、初次构建代码行数，算法构建能力评估中的代码行数、时间损耗和空间损耗。

| 指标名称                         | 指标类型 |
| -------------------------------- | -------- |
| 代码行数（算法构建能力）         | 极小型   |
| 时间损耗（算法构建能力）         | 极小型   |
| 空间损耗（算法构建能力）         | 极小型   |
| 得分涨幅（debug能力）            | 极大型   |
| 上传次数（debug能力）            | 极小型   |
| 上传间隔时间（debug能力）        | 极小型   |
| 初次得分（初次构建能力）         | 极大型   |
| 初次上传时间（初次构建能力）     | 极小型   |
| 初次构建代码行数（初次构建能力） | 极小型   |

数据处理首先将每道题的所有人答题情况进行汇总并整理，然后对于极小型指标依次取出最大值进行正向化并得到数据矩阵。

b.标准化处理

 为了消去不同指标量纲的影响， 需要对已经正向化的矩阵进行标准化处理。

​     标准化处理的计算公式

![](https://s1.ax1x.com/2020/07/27/aiL7DS.png)

​    即每个元素除以其所在列各元素平方和的开方。

c.计算评分（结合熵权法）

根据TOPSIS评价法，此步数据处理需取各列元素的最大值，组成一个列向量Z+，取各列元素的最小值，组成一个列向量Z-，计算每列元素与最大值组成的列向量Z+的距离D+，与最小值组成的列向量Z-的距离D-，在根据评分公式：D-/(D+ + D-）为每个对象进行打分。

![](https://s1.ax1x.com/2020/07/27/aiOsGn.png)

根据上面的评分公式，为各评价对象进行打分。
此处计算评价对象与最大值、最小值距离时，利用熵权法得到的各项指标的权重代入计算，使得结果更加客观有效。

**3.模型优势**

TOPSIS法对数据分布及样本量、指标多少无严格控制，数学计算亦不复杂，其应用范围广，具有直观的几何意义；它对原始数据的利用比较充分，信息损失少。而相较于德尔菲法、层次分析法等主观赋权法，本次数据处理中用到的熵权法更具有客观性，能够更好的对结果进行解释，其利用的是信息之间的变异性（也就是差异性）来进行赋权的。因此，对TOPSIS评价的最终结果进行结合熵权法的处理使得处理结果更加客观。

#### 熵权法构建学生题目类别级别评价模型

**原理阐释：**

在确定指标权重时，往常主要是根据评价者的主观看法，人为确定权重。尽管权重是按重要性给出，但由于没有充分考虑各指标提供的信息量，人为给出的权重显然缺乏客观的科学依据，因而势必会导致对某一题过高或过低的估计，从而使得评价不能完全合理的反应学生该题目类型的真实综合评价，因此使用熵权法

在信息论中，熵是对不确定性的一种度量。信息量越大，不确定性就越小，熵也就越小；信息量越小，不确定性越大，熵也越大。不难理解，如果某个指标的信息熵越小，就表明其指标值的变异程度越大，提供的信息量越大，在综合评价中所起的作用越大，则其权重也应越大。反之，某指标的信息熵越大，就表明其指标值的变异程度越小，提供的信息量越小，在综合评价中所起的作用越小，则其权重也应越小。所以在具体分析过程中，可根据各个指标值的变异程度，利用熵来计算出各指标权重，再对所有指标进行加权，从而得出较为客观的综合评价结果。

主要通过熵权法来获得一类题（不同指标评分单独）下的各个题目的权重，从而将对题目的三项评价整合提升为该题目类型的三项评价。

**处理过程：**

1.设立综合评价指标矩阵：

横坐标（表头）为评价的目标学生一类题所做的所有题号，表内数据每一列填充该题号对应系统中的所有记录（对应的指标：算法构建评价|debug评价|第一次构建评价）评价值。消除残缺行，从而构建出学生一类题具体指标的评价矩阵。

2.指标（一类题下的题目）的归一化处理：异质指标同质化

​		由于各项指标的计量单位并不统一，因此在用它们计算综合指标前，先要对它们进行标准化处理，即把指标的绝对值转化为相对值，并令![img](http://latex.codecogs.com/gif.latex?x_%7Bij%7D=%7Cx_%7Bij%7D%7C)，从而解决各项不同质指标值的同质化问题。其具体方法如下:



![](https://s1.ax1x.com/2020/07/27/aiXPQP.gif)

3.利用熵权法确定权重:

-  1.计算Pij（第j项指标下第i个具体指标评价值的 比重）：

![](https://s1.ax1x.com/2020/07/27/aiz3cR.png)

- 2.计算第j项指标的熵值：

![](https://s1.ax1x.com/2020/07/27/aixbfH.png)

​		其中，K=1/Ln（n）	

- 3.计算第j项指标的差异系数：
  ![g_{j}=1-e_{j}](https://private.codecogs.com/gif.latex?g_%7Bj%7D%3D1-e_%7Bj%7D)

- 4.计算第j项指标的权重

![](https://s1.ax1x.com/2020/07/27/aiz2E8.gif)

4.计算学生评价指标下题目类型的综合得分：

![](https://s1.ax1x.com/2020/07/27/aFSk5D.png)

#### RSR学生三项能力评价模型

#### 1.该层次数据来源与数据目标

该层次的原始数据来源于熵权法构建的学生各类别题目三项能力评价模型，在经过RSR模型处理之后，每名学生的8*3个能力数据将综合为每名学生的debug能力，第一次构建代码能力，算法构建能力这三项能力的RSR矫正值，我们最后将获得所有学生这三项能力的RSR矫正值的排行表。

#### 2.RSR评价模型

##### 1）.模型概念

秩和比法（即RSR评价模型，Rank-sum ratio）是一种将古典参数统计和近代非参数统计相结合，并融其各自优点于一身的统计分析方法，于1988年由我国的田风调教授提出，该模型适合对行列表格的资料进行综合评价，也可应用于分类及计量资料的综合评价，其基本思想为将一个 n 行（n 评价对象）p 列（p 个评价指标）矩阵通过秩转换，获得无量纲的统计量RSR，以RSR值对评价对象的优劣进行排序或分档排序。

##### 2）.具体算法思路

a.获得原始数据表

在使用RSR综合评价模型时，会根据评价目的，选择适合的评价指标，评价指标中有高优指标（即效益型指标，相当于TOPSIS模型中的极大型指标），低优指标（即成本型指标，相当于TOPSIS模型中的极小型指标）以及不分高优低优的指标。在我们的学生三项能力评价模型中，所有的评价指标都是经过上层数据处理得到的用积分评判的指标，因此均为高优指标。

在学生三项能力评价模型中，原始数据表为3个n*8的矩阵，其中n为user数即学生数量，8指的是学生在八类题型中某一种能力的评分，共有三项能力，故而有三个这样的矩阵。

b.对原始数据编秩

编秩是指对每个评价指标的值进行排序，得到一个秩次R，用得到的秩次R来代替原来的指标值，从而建立新的秩次数据矩阵。对于高优指标而言，指标值越高，秩越大。

编秩的方法有两种，分别为整秩法和非整秩法，在这里我们采用的是比较常用的整秩法。即高优指标从小到大编秩，低优指标从大到小编秩，同一指标数据相同者取平均值。

c.计算秩和比RSR值

<img src="https://s1.ax1x.com/2020/07/20/U4eout.png" style="zoom: 67%;" />

在这里，我们计算RSR值运用的是第一个公式，计算完成后，按RSR值对评价对象的优劣进行直接排序。

d.确定RSR分布

RSR 的分布是指用概率单位Probit表达的值特定的累计频率 .Probit模型是一种广义的线性模型，服从正态分布。具体步骤如下：

s1.将每个对象的RSR值按照升序排列

s2.编制RSR频数分布表，列出各组频数和各组累积频数

s3.对各组的RSR进行编秩算出秩次并算出平均秩次

s4.列出累计频率*R*ˉ/n ×100%，最后一项用（1-1/4n）×100%进行修正

s5.将上一步得到的累积频率转换为概率单位Probit

数据实例：

![](https://s1.ax1x.com/2020/07/28/aA8BDA.png)

​                                                           上图为算法构建能力RSR分布表前20行数据

e.计算直线回归方程

以概率单位值Probit 为自变量，以RSR值为因变量，计算回归方程：

RSR=a+b×Probit

在回归方程检验中，我们着重回归方程的拟合度检验，在本例中，方程的拟合度为97.1%。

<img src="https://s1.ax1x.com/2020/07/20/U4Q4gg.png" style="zoom:80%;" />

f.根据计算出的回归方程计算出RSR的矫正值。

数据实例：<img src="https://s1.ax1x.com/2020/07/28/aAGwGT.png"  />

上图为算法构建能力RSR矫正值列表的前20行数据，最后一列为RSR Regression

##### 3）.模型优缺点

优点：运用数据的相对大小代替数据真实值，可以减小异常值，离群数据的干扰，同时显示数据间的微小差异，该方法综合能力强，可以作为一个专门的综合指标来进行统计分析。此外，该方法以非参数法为基础，不引入主观变量，对指标的选择无特殊性要求，适用性很强。

缺点：最终排序的依据是对原始数据进行编秩后的秩次矩阵而并非原始数据本身，获得的RSR值也只能体现出综合秩次的差距，这就难以避免地会丢失掉一部分原始信息，从而导致对信息的利用不完全。

### 匹配算法

#### 数据来源

匹配算法的数据来源于熵权法处理下的学生各类型题目能力评估值以及在RSR秩和比法处理下的学生三项能力的评估值。即在UserAbilityTypeLevel.json中，每名学生在每类题型下都有三项指标的评分，在UserAbilityLevel.json中，每名学生的三项能力也各有一个综合评估值。

#### ELO概念

在匹配算法上我们主要借鉴了ELO等级分制度（ELO rating system），ELO等级分制度是由匈牙利裔美国物理学家Elo创建的一个衡量各类对弈活动选手水平的评分方法，是当今对弈水平评估的公认的权威方法，被广泛应用于国际象棋、围棋、足球等运动，以及很多网游与电子竞技产业，游戏界比较著名的应用有： WOW（魔兽世界）、DOTA、LOL。 

#### ELO计算方法

Ra：A玩家当前的Rating
Rb：B玩家当前的Rating
Ea：预期A选手的胜负值即预估胜率
Eb：预期B选手的胜负值即预估胜率

则有：

![](https://s1.ax1x.com/2020/07/28/aAObB6.png)

以上是我们借鉴的ELO等级分制度的计算部分

简单讲述一下Ea，Eb计算公式的来源：每一名选手在比赛中的表现都是符合正态分布的，他们的表现会围绕一个值上下波动，因而他们的表现符合正态分布函数：

![](https://s1.ax1x.com/2020/07/28/aEnfpj.png)

其中 U代表选手的平均水平，δ代表选手的稳定性，即表现分值的方差 

由此我们得到一个“正态概率密度”函数：

![](https://s1.ax1x.com/2020/07/28/aEuI8H.png)

其中D代表对手与该选手的表现分差值，P(D)表示该选手战胜对手的概率。

由于此公式较为复杂，在实际运用中利用了最小二乘进行模拟分析，得出了和它函数趋向相近的另外的一个公式： 

![](https://s1.ax1x.com/2020/07/28/aEMj3Q.png)

其中D代表对手与选手的表现分差，即为上面Ea，Eb的公式

#### 具体处理过程

对于三项评价指标而言，我们采用相似型匹配：

1.输入每名学生三项能力的RSR值

2.遍历字典，对每两名学生的每项能力的RSR值都采用ELO计算方法进行匹配计算，得到胜率差的绝对值，即

|Ea-Eb|

3.对每一位学生而言，将其他学生的三项能力RSR值对该学生采用2.计算之后，把三项能力胜率差的绝对值进行正向化处理，即用1-|胜率差|代替胜率差。因为我们在三项评价指标中采用的是相似型匹配，经过正向化处理之后，将三个值相加得到delta，这时delta值越大则代表原胜率差值之和越小，则两名同学的在三项能力层面上的水平就越接近。

4.对每一位学生而言，将其他学生与该学生经过算法处理得到的delta值按照降序排列，按delta值从高到低依次推荐5名学生作为匹配对象。其他学生的推荐对象同理，依次排列，详见abilityRec.json。

对于八种题目类型而言，我们采用互补型匹配：

1.输入每名学生八类题型的RSR值，在这里，上一步处理得到的每个学生毎类题型的RSR值有3个，分别对应三项能力，因而我们在这里对这三项能力进行人工赋权，按照算法构建能力0.4，debug能力0.4，第一次构建能力0.2进行赋权，计算出每个学生毎类题型的一个RSR值。

2.遍历字典，对每两名学生的每类题型的RSR值都采用ELO计算方法进行匹配计算，得到胜率差的绝对值，即

|Ea-Eb|

3.对每一位学生而言，将其他学生的八类题型RSR值对该学生采用2.计算之后，因为我们在八类题型中采用的是相似型匹配，将八个值相加即可得到delta，这时delta值越大则代表原胜率差值之和越大，则两名同学在八类题型层面上的水平差异就越大，即两名同学在擅长领域方面的差异更大。

4.对每一位学生而言，将其他学生与该学生经过算法处理得到的delta值按照降序排列，按delta值从高到低依次推荐5名学生作为匹配对象。其他学生的推荐对象同理，依次排列，详见caseTypeRec.json。

至此，我们的匹配算法就结束了，每一名学生的推荐编程伙伴列表也已得到。

## 案例分析

我们进行一下简单的案例分析。

![](https://s1.ax1x.com/2020/07/29/aVcbuj.jpg)

![](https://s1.ax1x.com/2020/07/29/aVcqDs.jpg)

以上两张雷达图展示的是user49823三项能力值和各类题型能力值的分布情况。在八类题型的能力分布中，该同学的能力分布相对而言是比较均匀的，其中排序算法尤为擅长，数组略显不足。在三项能力分布中，该同学的debug能力特别突出，第一次构建能力与算法构建能力则趋于平庸。

![](https://s1.ax1x.com/2020/07/29/aVgNRS.png)

上图是我们选取了user49823和与其三项能力匹配中的推荐位第一第五名的同学绘制的相似型匹配雷达图，从图中我们可以看到，推荐位第一和第五的同学与user49823在三项能力上相似度都非常高，user60778则与他的能力更为接近。这样，我们可以清楚地看到向user49823推荐的编程伙伴都是与其在三项能力上相当的同学。

![](https://s1.ax1x.com/2020/07/29/aV2ELj.png)

由于user49823的互补型匹配数据较为极端，我们选取了user60580和与其八种题型匹配中的推荐位第一第五名的同学绘制的互补型匹配雷达图。在本例中，推荐位第一与第五的同学在与user60580八种题型擅长领域的差异程度还是比较显著的。例如user60580在user60778表现极差的图结构类型中能力还是较为不错的，而user60580不擅长的查找算法、排序算法、数字操作类型就完全可以有擅长这些领域的user60778来带动学习，他们结伴编程的效益显然是比较高的。而user60580与推荐位第五的user60836的结伴效益则略逊一筹。

## 项目意义

项目通过对院系内学生提交的python代码作业进行特征数据分析，得到了每个学生在三项指标、八种题型中的能力评估值。学生可以了解到自己的算法构建能力，debug能力和第一次构建能力能够达到什么样的水平和在院系中的位次以及自己对八种题型的掌握程度和在院系中的位次。这样学生就不是仅仅通过最终成绩来对自身编程能力进行评估，而是通过本项目的分析数据，更加全面地了解到自身在编程能力上的优劣势，在各种题型中的长短板，从而可以有针对性地进行编程训练。

此外，本项目在得到了每个学生在三项指标、八种题型中的能力评估值之后，又利用所得评估数据，对院系学生进行了编程CP组配，在三项指标数据上我们采用了相似型匹配，这样能力相当，编程习惯相似的学生可以在一起合作编程，学生能够享受到很好的编程体验，这有利于组队编程的持续有效进行，在八种题型能力上我们采用了互补型匹配，这样擅长不同题型的同学可以进行组队编程，取长补短，共同进步。此外，我们采用了推荐制的组配方式，让学生根据我们得到的评价数据自由选择组配对象，这也体现了我们项目匹配的开放性。

由上，本项目可以促进院系内学生的结伴编程 。结伴编程对于程序员而言是有重要意义的，在编程的路上，如果有一群志同道合的小伙伴一起交流心得，相互鼓励，相互促进，这群人都会走得更远一些。对我们这个项目而言，我们三个人就算是简单的结伴编程，在此过程中，我们也能够感受到结伴编程的优势。 当我们正在结伴编程时，遇到了一个有挑战的问题，我们总可以找到可以一起讨论的人。在自己被问题卡住的时候，这样的谈话总更可能找到解决方法。随着工作轮换，我的解决方法也会被其它成员查看并重新考虑，所以如果一开始没有找到最好的解决办法也就没有关系了，并且我们时常能够在组员的闲聊中汲取他人的智慧从而获得解决问题的灵感。我们这只是简单的结伴编程，而我们的项目能够考虑到成员的编程能力和擅长领域，让编程能力相当而擅长不同领域的人在一起合作学习，这既能最大程度地保证结伴成员的愉快性，又特别适合于知识的分享和传递，特别适合于帮助开发者快速熟悉自己所不熟悉的领域。 这是我们项目结伴方式最为重要的意义。

## 项目应用

本项目可以应用于按照预定的评价指标对学校或院系内学生的编程能力进行综合性的评价，以及根据得到的评价数据为学生进行编程CP组配，为学生推荐合适的组配对象。当然，本项目也可以拓展到职场工作或科研工作中，根据员工或研究员以往的项目数据，设立合适的评价指标，对他们的编程能力或者其他方面的能力进行评估，并且推荐出合适的项目合作小组，以促进新的工作项目或科研项目的高效完成。

## 对陈老师说的话

希望陈老师能够在课堂上口若悬河之余，花适当多一些的时间在讲解案例上，并多与同学们互动，增加一些答疑的次数。也希望老师能够在课前说明一下课程提纲，并在指定一些参考书的同时能够基本按照教材内容顺序授课。